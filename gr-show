#!/bin/sh
#git recursive directories scripts - http://safrm.net/projects/gr-scripts
#author: Miroslav Safr <miroslav.safr@gmail.com>
#
VERSION=NA
VERSION_DATE=NA
#support color escape characters on different terminals
alias echo="/bin/echo -e"

BASENAME=`basename $0`
START_TIME=`date +'%s'`
usage() {
    echo "$BASENAME ${VERSION} "
    echo "Shows local tags versus current remote situation in subdirectories ./ or PROJECT_DIR/"
    echo "Usage:$BASENAME [OPTIONS]... PATTERN [PROJECT_DIR]"
    echo " PATTERN ............................. name or email of author or part of it "
    echo " options: "
    echo " -hm, --header-message ............... prints header message"
    echo " -v, --verbose ....................... prints more output"
    echo " -h, --help .......................... shows command line help"
    echo " -ns, --no-summary ................... do not print execution summary"
    echo " -V, --version  ...................... prints version of scripts"
    echo "Note: touch <dir>/.git/skip skips selected repo"
    echo " "
}


while [ $# -gt 0 ]; do
  case "$1" in
    -V | --version) echo "`basename $0` ${VERSION} ${VERSION_DATE}"; exit 0 ;;  
    -h | --help) usage; exit ;;
    -v|--verbose) 
               VERBOSE=1
               ;;
    -ns|--no-summary) 
               NO_SUMMARY=1
               ;;
	* )    PROJECT_DIR=$1;
	       ;; 
  esac
  shift
done

if [ -z "$PROJECT_DIR" ]
then
	PROJECT_DIR="./"
fi

if [ ! -d "$PROJECT_DIR" ] 
then
  echo "directory $PROJECT_DIR does not exist";
  exit 1
fi

CWD=`pwd`
cd $PROJECT_DIR
PROJECT_DIR=`pwd`


find "$PROJECT_DIR" -type d -name ".git*"  |  sed 's/\/.git//g' | sort | while read ENTRY
do
	if [ ! -f $ENTRY/.git/skip ]; then
		cd $ENTRY 
        LASTTAG=`git describe --tags --dirty=* --always 2> /dev/null`
        PROJECT20=`basename $ENTRY`
        PROJECT20=`printf '%-20s' $PROJECT20`
        #\c = without new line
        echo "\033[32m$PROJECT20\033[0m\c"
		BRANCH=`git branch | egrep "^\*" | cut -d' ' -f2`
    	git fetch origin 2> /dev/null
        if [ $? = 128 ] ; then
            NC="\033[41mNOT CONNECTED\033[0m "
        else
            NC=
    		git fetch origin --tags
        fi

        TO=`git describe origin/master --tags --always 2> /dev/null`

        LASTMSG=`git --no-pager log -1 --pretty=tformat:'%Cred%h%Creset - %s' | cut -c -80`
        echo "\033[31m[$BRANCH] \033[0m local:\033[34m$LASTTAG\033[0m remote:$NC\033[34m$TO\033[0m ($LASTMSG)"

        #local changes
    	LOCAL_CHANGES=`git status -s`
    	LOCAL_CHANGES_COUNT=`echo "$LOCAL_CHANGES" | grep -v '^$'| wc -l`
        #remote & local repo
        COMMITCOUNT_PULL=0
        COMMITCOUNT_PUSH=0
		if [ "$LASTTAG" != "$TO" ]; then
            COMMITCOUNT_PULL=`git shortlog HEAD..origin/$BRANCH | grep -E '^[ ]+\w+' | wc -l`
			COMMITCOUNT_PUSH=`git shortlog origin/$BRANCH..$BRANCH | grep -E '^[ ]+\w+' | wc -l`
		fi

        if [ "x$LOCAL_CHANGES_COUNT" != "x0" ] || [ "x$COMMITCOUNT_PULL" != "x0" ] || [ "x$COMMITCOUNT_PUSH" != "x0" ] 
        then
            echo "\033[43m NEEDS UPDATE OR COMMIT (pull:$COMMITCOUNT_PULL/push:$COMMITCOUNT_PUSH/local-files:$LOCAL_CHANGES_COUNT)\033[0m"    
        fi

        if [ ! -z "$VERBOSE" ] && [ "x$LOCAL_CHANGES" != "x" ] ; then
            echo "$LOCAL_CHANGES"
    	fi
		cd $PROJECT_DIR
	fi
done

if [ -z "$NO_SUMMARY" ]; then
	TIME=`date +%H:%M:%S`
	ELAPSED_TIME=$((`date +'%s'` - $START_TIME))
	echo "$BASENAME finished:$TIME took:$(($ELAPSED_TIME/60)) min $(($ELAPSED_TIME%60)) s"
fi
