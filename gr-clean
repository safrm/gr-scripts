#!/bin/sh
#git recursive directories scripts - http://safrm.net/projects/gr-scripts
#author: Miroslav Safr <miroslav.safr@gmail.com>
VERSION=NA
VERSION_DATE=NA
#support color escape characters on different terminals
alias echo="/bin/echo -e"

BASENAME=`basename $0`
START_TIME=`date +'%s'`
usage() {
    echo "$BASENAME ${VERSION}"
    echo "cleans up git clones in all subdirectories ./ or $1/ except those which are marked by:"
    echo "  touch <dir>/.git/no_updates"
    echo "Usage:$BASENAME [OPTIONS]... [PROJECT_DIR]"
    echo " options: "
    echo " --help ............................. shows command line help"
    echo " -ns, --no-summary ................... do not print execution summary"
    echo " -V, --version  ...................... prints version of scripts"
    echo " "
}

while [ $# -gt 0 ]; do
  case "$1" in
    --help) usage; exit ;;
    -V | --version) echo "`basename $0` ${VERSION} ${VERSION_DATE}"; exit 0 ;;  
    -ns|--no-summary) 
               NO_SUMMARY=1
               ;;
	* )    PROJECT_DIR=$1;
	       ;; 
  esac
  shift
done

if [ -z "$PROJECT_DIR" ]
then
	PROJECT_DIR="./"
fi

if [ ! -d "$PROJECT_DIR" ] 
then
  echo "directory $PROJECT_DIR does not exist";
  exit 1
fi

CWD=`pwd`
cd $PROJECT_DIR
PROJECT_DIR=`pwd`

find "$PROJECT_DIR" -type d -name ".git*"  |  sed 's/\/.git//g' | sort | while read ENTRY
do
	if [ -d $ENTRY ] && [ -d $ENTRY/.git ]; then
		if [ ! -f $ENTRY/.git/no_updates ]; then
			cd $ENTRY 
            LASTTAG=`git describe --tags --dirty=* --always 2> /dev/null`
            PROJECT20=`basename $ENTRY`
            PROJECT20=`printf '%-20s' $PROJECT20`
            echo "\033[32m $ENTRY\033[0m cleaning.." 
			BRANCH=`git branch | egrep "^\*" | cut -d' ' -f2`
			git reset --hard origin/$BRANCH
            git gc --quiet
            git clean -dfx
			cd $PROJECT_DIR
		else
			echo "\033[32m $ENTRY\033[0m \033[35m skipped clean \033[0m" 
		fi
	fi
done

if [ -z "$NO_SUMMARY" ]; then
	TIME=`date +%H:%M:%S`
	ELAPSED_TIME=$((`date +'%s'` - $START_TIME))
	echo "$BASENAME finished:$TIME took:$(($ELAPSED_TIME/60)) min $(($ELAPSED_TIME%60)) s"
fi

